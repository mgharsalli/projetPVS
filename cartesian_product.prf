(cartesian_product
 (emptyset_product 0
  (emptyset_product-1 nil 3564386404
   ("" (skosimp)
    (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil))
    nil)
   ((T formal-type-decl nil cartesian_product nil)
    (U formal-type-decl nil cartesian_product nil)
    (boolean nonempty-type-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (* const-decl "[T, U -> bool]" cartesian_product nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (add_product_union 0
  (add_product_union-1 nil 3564386339
   ("" (skosimp)
    (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil))
    nil)
   ((T formal-type-decl nil cartesian_product nil)
    (U formal-type-decl nil cartesian_product nil)
    (boolean nonempty-type-decl nil booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (* const-decl "[T, U -> bool]" cartesian_product nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (cartesian_product_finite 0
  (cartesian_product_finite-1 nil 3564384856
   ("" (skolem * ("_" "us"))
    (("" (rewrite "finite_set_induction")
      (("1" (rewrite "emptyset_product") (("1" (ground) nil nil)) nil)
       ("2" (hide 2)
        (("2" (skolem * ("e" "S"))
          (("2" (flatten)
            (("2" (rewrite "add_product_union")
              (("2" (rewrite "finite_union")
                (("2" (hide-all-but 1)
                  (("2" (expand "is_finite")
                    (("2" (typepred "us")
                      (("2" (expand "is_finite")
                        (("2" (skolem * ("Nus" "fus"))
                          (("2"
                            (inst * "Nus"
                             "(LAMBDA (tu:(singleton(e)*us)): fus(tu`2))")
                            (("1" (expand "injective?" +)
                              (("1"
                                (skolem * ("tu1" "tu2"))
                                (("1"
                                  (typepred "tu1")
                                  (("1"
                                    (typepred "tu2")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand "injective?" *)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (apply-extensionality 1)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set_induction formula-decl nil finite_sets_inductions
     "finite_sets/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (U formal-type-decl nil cartesian_product nil)
    (* const-decl "[T, U -> bool]" cartesian_product nil)
    (T formal-type-decl nil cartesian_product nil)
    (finite_emptyset name-judgement "finite_set[T]" cartesian_product
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[T]" cartesian_product nil)
    (emptyset_product formula-decl nil cartesian_product nil)
    (add_product_union formula-decl nil cartesian_product nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" cartesian_product nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (us skolem-const-decl "finite_set[U]" cartesian_product nil)
    (e skolem-const-decl "T" cartesian_product nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil))
   nil)))

